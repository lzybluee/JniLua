<Card>
<SetId>SC</SetId>
<No>94</No>
<Name>Goblin Brigand</Name>
<Type>Creature ！ Goblin Warrior 2/2</Type>
<ManaCost>1R (2)</ManaCost>
<CardText>Goblin Brigand attacks each turn if able.</CardText>
<Flavor>After the Skirk Ridge collapsed, the goblins erected a system of ropes and pulleys to hold up what was left.</Flavor>
<Artist>Arnie Swekel</Artist>
<Multiverseid>43525</Multiverseid>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Modern>Legal</Modern>
<Set>Scourge</Set>
<Rarity>Common</Rarity>
</Card>

<-------------------->
Goblin Brigand
Creature ！ Goblin Warrior 2/2
1R (2)
Goblin Brigand attacks each combat if able.
Legal in Modern/Legacy/Vintage
83374 Ninth Edition : 190 (Common) Arnie Swekel
Like a loaded cannon！point and shoot.

<Card>
<SetId>BE</SetId>
<No>26</No>
<Name>Nettling Imp</Name>
<Type>Creature ！ Imp 1/1</Type>
<ManaCost>2B (3)</ManaCost>
<CardText>{T}: Choose target non-Wall creature the active player has controlled continuously since the beginning of the turn. That creature attacks this turn if able. If it doesn't, destroy it at the beginning of the next end step. Activate this ability only during an opponent's turn, before attackers are declared.</CardText>
<Artist>Quinton Hoover</Artist>
<Multiverseid>368</Multiverseid>
<Rulings>2004/10/04: If the Imp leaves the battlefield before the end of the turn, the creature still is destroyed.
2004/10/04: You can use this effect on a creature you know won't be able to attack. For example, you can use it on a tapped creature.
2004/10/04: The creature is destroyed if it does not attack because it simply can't do so legally.
2013/09/20: If a turn has multiple combat phases, the ability can only be activated before the beginning of the declare attackers step of the first combat phase in that turn.</Rulings>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Set>Limited Edition Beta</Set>
<Rarity>Uncommon</Rarity>
</Card>

<-------------------->
Nettling Imp
Creature ！ Imp 1/1
2B (3)
{T}: Choose target non-Wall creature the active player has controlled continuously since the beginning of the turn. That creature attacks this turn if able. Destroy it at the beginning of the next end step if it didn't attack this turn. Activate this ability only during an opponent's turn, before attackers are declared.
2004/10/04: If the Imp leaves the battlefield before the end of the turn, the creature still is destroyed.
2004/10/04: You can use this effect on a creature you know won't be able to attack. For example, you can use it on a tapped creature.
2004/10/04: The creature is destroyed if it does not attack because it simply can't do so legally.
2013/09/20: If a turn has multiple combat phases, the ability can only be activated before the beginning of the declare attackers step of the first combat phase in that turn.
Legal in Legacy/Vintage
1169 Revised Edition : 27 (Uncommon) Quinton Hoover
670 Unlimited Edition : 26 (Uncommon) Quinton Hoover

<Card>
<SetId>BE</SetId>
<No>104</No>
<Name>Fungusaur</Name>
<Type>Creature ！ Fungus Lizard 2/2</Type>
<ManaCost>3G (4)</ManaCost>
<CardText>Whenever Fungusaur is dealt damage, put a +1/+1 counter on it.</CardText>
<Flavor>Rather than sheltering her young, the female Fungusaur often injures her own offspring, thereby ensuring their rapid growth.</Flavor>
<Artist>Daniel Gelon</Artist>
<Multiverseid>446</Multiverseid>
<Rulings>2004/10/04: If more than one creature damages it at one time, it only gets one counter.</Rulings>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Modern>Legal</Modern>
<Set>Limited Edition Beta</Set>
<Rarity>Rare</Rarity>
</Card>

<-------------------->
Fungusaur
Creature ！ Fungus Dinosaur 2/2
3G (4)
Whenever Fungusaur is dealt damage, put a +1/+1 counter on it.
2004/10/04: If more than one creature damages it at one time, it only gets one counter.
Legal in Modern/Legacy/Vintage
45441 Eighth Edition : 250 (Rare) Heather Hudson
3979 Fifth Edition : 158 (Rare) Scott M. Fischer
2213 Fourth Edition : 130 (Rare) Daniel Gelon
1246 Revised Edition : 104 (Rare) Daniel Gelon
748 Unlimited Edition : 104 (Rare) Daniel Gelon
Rather than sheltering her young, the female fungusaur often injures her own offspring, thereby ensuring their rapid growth.

<Card>
<SetId>BE</SetId>
<No>257</No>
<Name>Juggernaut</Name>
<Type>Artifact Creature ！ Juggernaut 5/3</Type>
<ManaCost>4 (4)</ManaCost>
<CardText>Juggernaut attacks each turn if able.
Juggernaut can't be blocked by Walls.</CardText>
<Flavor>We had taken refuge in a small cave, thinking the entrance was too narrow for it to follow. To our horror, its gigantic head smashed into the mountainside, ripping itself a new entrance.</Flavor>
<Artist>Dan Frazier</Artist>
<Multiverseid>321</Multiverseid>
<Rulings>2016/06/08: If, during your declare attackers step, <Juggernaut> is tapped, is affected by a spell or ability that says it can't attack, or you haven't controlled it continuously since the beginning of your turn, then it doesn't attack. If there's a cost associated with having <Juggernaut> attack, you aren't forced to pay that cost, so it doesn't have to attack in that case either.
2016/06/08: If there are multiple combat phases in a turn, <Juggernaut> must attack only in the first one in which it's able to.</Rulings>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Modern>Legal</Modern>
<Set>Limited Edition Beta</Set>
<Rarity>Uncommon</Rarity>
</Card>

<-------------------->
Juggernaut
Artifact Creature ！ Juggernaut 5/3
4 (4)
Juggernaut attacks each combat if able.
Juggernaut can't be blocked by Walls.
2016/06/08: If, during your declare attackers step, <Juggernaut> is tapped, is affected by a spell or ability that says it can't attack, or you haven't controlled it continuously since the beginning of your turn, then it doesn't attack. If there's a cost associated with having <Juggernaut> attack, you aren't forced to pay that cost, so it doesn't have to attack in that case either.
Legal in Modern/Legacy/Vintage
383289 Magic 2015 : 220 (Uncommon) Kev Walker
205230 Magic 2011 : 209 (Uncommon) Mark Hyzer
135240 Tenth Edition : 328 (Uncommon) Arnie Swekel
43579 Darksteel : 125 (Uncommon) Arnie Swekel
1120 Revised Edition : 259 (Uncommon) Dan Frazier
623 Unlimited Edition : 256 (Uncommon) Dan Frazier
Many a besieged city has surrendered upon hearing the distinctive rumble of the juggernaut.
The mighty city of An Karras, with its rich history, built over thousands of years, fell in three hours.
Built with neither a way to steer nor a way to stop, the juggernauts were simply aimed at an enemy's best defenses and told to charge.
The goblins built it far larger than the cave opening, but to their glee, it smashed into the mountainside, ripping itself a new exit.
We had taken refuge in a small cave, thinking the entrance was too narrow for it to follow. To our horror, its gigantic head smashed into the mountainside, ripping itself a new entrance.

<Card>
<SetId>RIX</SetId>
<No>183</No>
<Name>Strider Harness</Name>
<Type>Artifact ！ Equipment</Type>
<ManaCost>3 (3)</ManaCost>
<CardText>Equipped creature gets +1/+1 and has haste.
Equip {1} ({1}: Attach to target creature you control. Equip only as a sorcery.)</CardText>
<Flavor>"Because the giant, implacable death lizard wasn't scary enough already."
！Captain Brinely Rage</Flavor>
<Artist>Kev Walker</Artist>
<Multiverseid>439847</Multiverseid>
<Rulings>2018/01/19: If a creature enters the battlefield under your control and gains haste, but then loses it before attacking, it won't be able to attack that turn. This means that you can't use one <Strider Harness> to allow two new creatures to attack in the same turn.</Rulings>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Modern>Legal</Modern>
<Set>Rivals of Ixalan</Set>
<Rarity>Common</Rarity>
</Card>

<-------------------->
Strider Harness
Artifact ！ Equipment
3 (3)
Equipped creature gets +1/+1 and has haste.
Equip {1}
Legal in Modern/Legacy/Vintage
(Watermark: Mirran)
407677 Oath of the Gatewatch : 167 (Uncommon) Kev Walker
206344 Scars of Mirrodin : 207 (Common) Matt Stewart
"Sometimes being fast is as important as being smart."
！Ryza, Oran-Rief scout
Each journey begins with a single step！and sometimes ends with that single step as well.

<Card>
<SetId>RIX</SetId>
<No>184</No>
<Name>Traveler's Amulet</Name>
<Type>Artifact</Type>
<ManaCost>1 (1)</ManaCost>
<CardText>{1}, Sacrifice Traveler's Amulet: Search your library for a basic land card, reveal it, put it into your hand, then shuffle your library.</CardText>
<Flavor>"The best kind of treasure is the kind that leads to more treasure!"
！Captain Lannery Storm</Flavor>
<Artist>Yeong-Hao Han</Artist>
<Multiverseid>439848</Multiverseid>
<Vintage>Legal</Vintage>
<Legacy>Legal</Legacy>
<Modern>Legal</Modern>
<Set>Rivals of Ixalan</Set>
<Rarity>Common</Rarity>
</Card>

<-------------------->
Traveler's Amulet
Artifact
1 (1)
{1}, Sacrifice Traveler's Amulet: Search your library for a basic land card, reveal it, and put it into your hand. Then shuffle your library.
Legal in Modern/Legacy/Vintage
430856 Hour of Devastation : 167 (Common) Marco Nelor
373690 Theros : 221 (Common) Franz Vohwinkel
237357 Innistrad : 234 (Common) Alan Pollack
"Why wander in search of a new home when the path is laid out before you?"
！Pytamun, former Nef-crop initiate
"What we call magic is nothing more than hope crystallized into a destination."
！Perisophia the philosopher
The rider set off into the eerie mist, swaddled in armor and laden with amulets.

*******************************************************

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import org.json.JSONArray;
import org.json.JSONObject;

public class Main {

	static String[][] SETS = { { "Hour of Devastation", "HOU" }, { "Amonkhet", "AKH" }, { "Aether Revolt", "AER" },
			{ "Kaladesh", "KLD" }, { "Eldritch Moon", "EMN" }, { "Shadows over Innistrad", "SOI" },
			{ "Oath of the Gatewatch", "OGW" }, { "Battle for Zendikar", "BFZ" }, { "Magic Origins", "ORI" },
			{ "Dragons of Tarkir", "DTK" }, { "Fate Reforged", "FRF" }, { "Khans of Tarkir", "KTK" },
			{ "Magic 2015", "M15" }, { "Journey into Nyx", "JOU" }, { "Born of the Gods", "BNG" }, { "Theros", "THS" },
			{ "Magic 2014", "M14" }, { "Dragon's Maze", "DGM" }, { "Gatecrash", "GTC" }, { "Return to Ravnica", "RTR" },
			{ "Magic 2013", "M13" }, { "Avacyn Restored", "AVR" }, { "Dark Ascension", "DKA" }, { "Innistrad", "ISD" },
			{ "Magic 2012", "M12" }, { "New Phyrexia", "NPH" }, { "Mirrodin Besieged", "MBS" },
			{ "Scars of Mirrodin", "SOM" }, { "Magic 2011", "M11" }, { "Rise of the Eldrazi", "ROE" },
			{ "Worldwake", "WWK" }, { "Zendikar", "ZEN" }, { "Magic 2010", "M10" }, { "Alara Reborn", "ARB" },
			{ "Conflux", "CFX" }, { "Shards of Alara", "ALA" }, { "Eventide", "EVE" }, { "Shadowmoor", "SHM" },
			{ "Morningtide", "MT" }, { "Lorwyn", "LW" }, { "Tenth Edition", "10E" }, { "Future Sight", "FUT" },
			{ "Planar Chaos", "PC" }, { "Time Spiral \"Timeshifted\"", "TSTS" }, { "Time Spiral", "TS" },
			{ "Coldsnap", "CS" }, { "Dissension", "DI" }, { "Guildpact", "GP" }, { "Ravnica: City of Guilds", "RAV" },
			{ "Ninth Edition", "9E" }, { "Ninth Edition Boxed Set", "9EB" }, { "Saviors of Kamigawa", "SOK" },
			{ "Betrayers of Kamigawa", "BOK" }, { "Champions of Kamigawa", "CHK" }, { "Fifth Dawn", "5DN" },
			{ "Darksteel", "DS" }, { "Mirrodin", "MI" }, { "Eighth Edition", "8E" },
			{ "Eighth Edition Boxed Set", "8EB" }, { "Scourge", "SC" }, { "Legions", "LE" }, { "Onslaught", "ON" },
			{ "Judgment", "JU" }, { "Torment", "TR" }, { "Odyssey", "OD" }, { "Apocalypse", "AP" },
			{ "Seventh Edition", "7E" }, { "Planeshift", "PS" }, { "Invasion", "IN" }, { "Prophecy", "PR" },
			{ "Nemesis", "NE" }, { "Mercadian Masques", "MM" }, { "Urza's Destiny", "UD" },
			{ "Classic Sixth Edition", "6E" }, { "Urza's Legacy", "UL" }, { "Urza's Saga", "US" }, { "Exodus", "EX" },
			{ "Stronghold", "SH" }, { "Tempest", "TP" }, { "Weatherlight", "WL" }, { "Fifth Edition", "5E" },
			{ "Visions", "VI" }, { "Mirage", "MR" }, { "Alliances", "AI" }, { "Homelands", "HL" }, { "Ice Age", "IA" },
			{ "Fourth Edition", "4E" }, { "Fallen Empires", "FE" }, { "The Dark", "DK" }, { "Legends", "LG" },
			{ "Revised Edition", "RV" }, { "Antiquities", "AQ" }, { "Arabian Nights", "AN" },
			{ "Unlimited Edition", "UN" }, { "Limited Edition Beta", "BE" }, { "Limited Edition Alpha", "AL" },
			{ "Commander 2017 Edition", "C17" }, { "Commander 2016 Edition", "C16" },
			{ "Commander 2015 Edition", "C15" }, { "Commander 2014 Edition", "C14" },
			{ "Commander 2013 Edition", "C13" }, { "Commander", "CMD" }, { "Planechase Anthology", "PCA" },
			{ "Planechase 2012 Edition", "PC2" }, { "Planechase", "PCH" }, { "Conspiracy: Take the Crown", "CN2" },
			{ "Conspiracy", "CNS" }, { "Portal Three Kingdoms", "P3K" }, { "Portal Second Age", "PO2" },
			{ "Portal", "PO" }, { "Starter 1999", "ST" }, { "Media Inserts", "MBP" },
			{ "Archenemy: Nicol Bolas", "E01" }, { "Archenemy", "ARC" }, { "Modern Masters 2017 Edition", "MM3" },
			{ "Modern Masters 2015 Edition", "MM2" }, { "Modern Masters", "MMA" }, { "Eternal Masters", "EMA" },
			{ "Vintage Masters", "VMA" }, { "Welcome Deck 2017", "W17" }, { "Welcome Deck 2016", "W16" },
			{ "Duel Decks: Mind vs. Might", "DDS" }, { "Duel Decks: Nissa vs. Ob Nixilis", "DDR" },
			{ "Duel Decks: Blessed vs. Cursed", "DDQ" }, { "Duel Decks: Zendikar vs. Eldrazi", "DDP" },
			{ "Duel Decks: Kiora vs. Elspeth", "DDO" }, { "Duel Decks: Speed vs. Cunning", "DDN" },
			{ "Duel Decks: Jace vs. Vraska", "DDM" }, { "Duel Decks: Heroes vs. Monsters", "DDL" },
			{ "Duel Decks: Sorin vs. Tibalt", "DDK" }, { "Duel Decks: Izzet vs. Golgari", "DDJ" },
			{ "Duel Decks: Venser vs. Koth", "DDI" }, { "Duel Decks: Ajani vs. Nicol Bolas", "DDH" },
			{ "Duel Decks: Knights vs. Dragons", "DDG" }, { "Duel Decks: Elspeth vs. Tezzeret", "DDF" },
			{ "Duel Decks: Phyrexia vs. the Coalition", "PVC" }, { "Duel Decks: Garruk vs. Liliana", "GVL" },
			{ "Duel Decks: Divine vs. Demonic", "DVD" }, { "Duel Decks: Jace vs. Chandra", "JVC" },
			{ "Duel Decks: Elves vs. Goblins", "EVG" }, { "From the Vault: Lore", "V16" },
			{ "From the Vault: Angels", "V15" }, { "From the Vault: Annihilation", "V14" },
			{ "From the Vault: Twenty", "V13" }, { "From the Vault: Realms", "V12" },
			{ "From the Vault: Legends", "FVL" }, { "From the Vault: Relics", "FVR" },
			{ "From the Vault: Exiled", "FVE" }, { "From the Vault: Dragons", "FVD" },
			{ "Premium Deck Series: Graveborn", "PD3" }, { "Premium Deck Series: Fire and Lightning", "PD2" },
			{ "Premium Deck Series: Slivers", "PDS" }, { "MTGO Masters Edition IV", "ME4" },
			{ "MTGO Masters Edition III", "ME3" }, { "MTGO Masters Edition II", "ME2" },
			{ "MTGO Masters Edition", "MED" }, { "Commander's Arsenal", "CMA" }, { "Chronicles", "CH" },
			{ "Masterpiece Series: Amonkhet Invocations", "MPSAKH" },
			{ "Masterpiece Series: Kaladesh Inventions", "MPSKLD" }, { "Zendikar Expeditions", "EXP" },
			{ "Unstable", "UST" }, { "Unhinged", "UH" }, { "Unglued", "UG" } };

	static StringBuffer out;

	static void printEntry(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			out.append("<" + desc + ">" + card.get(key) + "</" + desc + ">\n");
		}
	}

	static void printNo(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			out.append("<" + desc + ">" + card.getString(key) + "</" + desc + ">\n");
		} else if (card.has("mciNumber")) {
			out.append("<" + desc + ">" + card.getString("mciNumber") + "</" + desc + ">\n");
		}

	}

	static void printName(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			String name = null;
			if (card.has("layout")
					&& (card.getString("layout").equals("split") || card.getString("layout").equals("aftermath"))) {
				JSONArray names = card.getJSONArray("names");
				int size = names.length();
				String suffix = "(";
				for (int i = 0; i < size; i++) {
					suffix += names.getString(i);
					if (i < size - 1) {
						suffix += "/";
					}
				}
				suffix += ")";
				name = card.getString(key) + " " + suffix;
			} else {
				name = card.getString(key);
			}
			out.append("<" + desc + ">" + name + "</" + desc + ">\n");
		}
	}

	static String reorderMana(String mana) {
		String s = mana;
		int w = 0, u = 0, b = 0, r = 0, g = 0;
		boolean noColorMana = false;
		while (s.length() > 0) {
			switch (s.toCharArray()[s.length() - 1]) {
			case 'W':
				w++;
				break;
			case 'U':
				u++;
				break;
			case 'B':
				b++;
				break;
			case 'R':
				r++;
				break;
			case 'G':
				g++;
				break;
			default:
				noColorMana = true;
				break;
			}
			if (noColorMana) {
				break;
			} else {
				s = s.substring(0, s.length() - 1);
			}
		}
		for (int i = 0; i < w; i++) {
			s += "W";
		}
		for (int i = 0; i < u; i++) {
			s += "U";
		}
		for (int i = 0; i < b; i++) {
			s += "B";
		}
		for (int i = 0; i < r; i++) {
			s += "R";
		}
		for (int i = 0; i < g; i++) {
			s += "G";
		}
		return s;
	}

	static boolean isColorless(String mana) {
		if (mana.contains("W") || mana.contains("U") || mana.contains("B") || mana.contains("R")
				|| mana.contains("G")) {
			return false;
		}
		return true;
	}

	static void printMana(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			String mana = card.getString(key);
			mana = mana.replaceAll("/P", "P").replaceAll("\\{(.)\\}", "$1").replaceAll("\\{(\\d+)\\}", "$1");
			if (!mana.contains("{")) {
				mana = reorderMana(mana);
			}
			out.append("<" + desc + ">" + mana + " (" + card.getInt("cmc") + ")</" + desc + ">\n");
		}
		if ((!card.has(key) && card.has("colors"))
				|| (card.has(key) && card.has("colors") && isColorless(card.getString(key)))) {
			JSONArray colors = card.getJSONArray("colors");
			int size = colors.length();
			out.append("<ColorIndicator>");
			for (int i = 0; i < size; i++) {
				out.append(colors.getString(i));
				if (i < size - 1) {
					out.append(" ");
				}
			}
			out.append("</ColorIndicator>\n");
		}
	}

	static void printText(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			out.append("<" + desc + ">" + card.getString(key).replace("/P}", "P}") + "</" + desc + ">\n");
		} else {
			String mana = null;
			switch (card.getString("name")) {
			case "Plains":
			case "Snow-Covered Plains":
				mana = "W";
				break;
			case "Island":
			case "Snow-Covered Island":
				mana = "U";
				break;
			case "Swamp":
			case "Snow-Covered Swamp":
				mana = "B";
				break;
			case "Mountain":
			case "Snow-Covered Mountain":
				mana = "R";
				break;
			case "Forest":
			case "Snow-Covered Forest":
				mana = "G";
				break;
			}
			if (mana != null) {
				out.append("<" + desc + ">" + "({T}: Add {" + mana + "} to your mana pool.)" + "</" + desc + ">\n");
			}
		}
	}

	static void printType(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			String type = card.getString(key).replaceAll("¨", "'");
			if (card.has("power")) {
				type += " " + card.get("power") + "/" + card.get("toughness");
			}
			if (card.has("loyalty")) {
				type += " (Loyalty: " + card.get("loyalty") + ")";
			}
			out.append("<" + desc + ">" + type + "</" + desc + ">\n");
		}
	}

	static void printRulings(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			JSONArray rules = card.getJSONArray(key);
			StringBuffer buffer = new StringBuffer();
			int size = rules.length();
			for (int i = 0; i < size; i++) {
				JSONObject rule = rules.getJSONObject(i);
				String date = rule.getString("date");
				buffer.append(date.replaceAll("-", "/") + ": " + rule.get("text"));
				if (i < size - 1) {
					buffer.append("\n");
				}
			}
			String name = card.getString("name");
			String str = buffer.toString().replaceAll(name, "<" + name + ">");
			out.append("<" + desc + ">" + str + "</" + desc + ">\n");
		}
	}

	static void printLegal(JSONArray legals, String key) {
		int size = legals.length();
		String str = null;
		for (int i = 0; i < size; i++) {
			JSONObject legal = legals.getJSONObject(i);
			if (legal.getString("format").equals(key)) {
				str = legal.getString("legality");
				break;
			}
		}
		if (str != null) {
			out.append("<" + key + ">" + str + "</" + key + ">\n");
		}
	}

	static void printLegals(JSONObject card, String key) {
		if (card.has(key)) {
			JSONArray legals = card.getJSONArray(key);
			printLegal(legals, "Vintage");
			printLegal(legals, "Legacy");
			printLegal(legals, "Modern");
		}
	}

	static void printRarity(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			out.append("<" + desc + ">" + card.getString(key).replace("Basic Land", "Land") + "</" + desc + ">\n");
		}
	}

	static void printOtherPart(JSONObject card, String key, String desc) {
		if (card.has(key)) {
			JSONArray names = card.getJSONArray(key);
			int size = names.length();
			for (int i = 0; i < size; i++) {
				String name = names.getString(i);
				if (!name.equals(card.getString("name"))) {
					if (card.has("layout") && (card.getString("layout").equals("split")
							|| card.getString("layout").equals("aftermath"))) {
						String suffix = "(";
						for (int j = 0; j < size; j++) {
							suffix += names.getString(j);
							if (j < size - 1) {
								suffix += "/";
							}
						}
						suffix += ")";
						name += " " + suffix;
					}
					out.append("<" + desc + ">" + name + "</" + desc + ">\n");
					break;
				}
			}
		}
	}

	static void printCard(JSONObject card, String code, String set) {
		out.append("<Card>\n");
		out.append("<SetId>" + code + "</SetId>\n");
		printNo(card, "number", "No");
		printName(card, "name", "Name");
		printType(card, "type", "Type");
		printMana(card, "manaCost", "ManaCost");
		printText(card, "text", "CardText");
		printEntry(card, "flavor", "Flavor");
		printEntry(card, "artist", "Artist");
		// printEntry(card, "watermark", "Watermark");
		printEntry(card, "multiverseid", "Multiverseid");
		printRulings(card, "rulings", "Rulings");
		if (card.has("reserved") && card.getBoolean("reserved")) {
			out.append("<Reserved>This card is on the reserved list</Reserved>\n");
		}
		printLegals(card, "legalities");
		out.append("<Set>" + set + "</Set>\n");
		printRarity(card, "rarity", "Rarity");
		printOtherPart(card, "names", "OtherPart");
		out.append("</Card>\n");
	}

	static void printSet(JSONObject all, String code) {
		out = new StringBuffer();

		JSONObject set = all.getJSONObject(code);
		String name = set.getString("name");

		System.out.println(code + " : " + name);

		if (name.startsWith("Commander 201") && !name.endsWith("Edition")) {
			name += " Edition";
		}

		for (String[] s : SETS) {
			if (name.equals(s[0])) {
				code = s[1];
				break;
			}
		}

		HashMap<String, JSONObject> map = new HashMap<>();

		JSONArray cards = set.getJSONArray("cards");
		int size = cards.length();
		for (int i = 0; i < size; i++) {
			JSONObject card = cards.getJSONObject(i);
			if (card.has("layout") && (card.getString("layout").equals("token")
					|| card.getString("layout").equals("plane") || card.getString("layout").equals("scheme")
					|| card.getString("layout").equals("phenomenon"))) {
				continue;
			}
			String num = "";
			if (card.has("number")) {
				num = card.getString("number");
			} else if (card.has("mciNumber")) {
				num = card.getString("mciNumber");
			}
			if (!num.isEmpty()) {
				map.put(num, card);
			}
			// printCard(card, code, name);
			// out.append("\n");
		}

		Vector<String> vector = new Vector<>();
		for (String s : map.keySet()) {
			vector.add(s);
		}
		Collections.sort(vector, new Comparator<String>() {

			@Override
			public int compare(String arg0, String arg1) {
				String n0 = arg0;
				String n1 = arg1;
				if (arg0.startsWith("S") || arg0.startsWith("￥")) {
					n0 = arg0.substring(1, arg0.length());
				}
				if (arg1.startsWith("S") || arg1.startsWith("￥")) {
					n1 = arg1.substring(1, arg1.length());
				}
				if (arg0.endsWith("a") || arg0.endsWith("b") || arg0.endsWith("c") || arg0.endsWith("d")
						|| arg0.endsWith("e")) {
					n0 = arg0.substring(0, arg0.length() - 1);
				}
				if (arg1.endsWith("a") || arg1.endsWith("b") || arg1.endsWith("c") || arg1.endsWith("d")
						|| arg1.endsWith("e")) {
					n1 = arg1.substring(0, arg1.length() - 1);
				}
				if (n0.equals(n1)) {
					return arg0.compareTo(arg1);
				} else {
					return Integer.parseInt(n0) - Integer.parseInt(n1);
				}
			}
		});
		for (String s : vector) {
			printCard(map.get(s), code, name);
			out.append("\n");
		}

		File file = new File("Oracle/MtgOracle_" + code + ".txt");
		BufferedWriter writer = null;
		try {
			writer = new BufferedWriter(new FileWriter(file));
			writer.write(out.toString());
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (writer != null) {
				try {
					writer.close();
				} catch (IOException e1) {
				}
			}
		}
	}

	public static void main(String[] args) {
		File file = new File("AllSets-x.json");
		BufferedReader reader = null;
		StringBuffer str = new StringBuffer();
		try {
			reader = new BufferedReader(new FileReader(file));
			String line = null;
			while ((line = reader.readLine()) != null) {
				str.append(line);
			}
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (reader != null) {
				try {
					reader.close();
				} catch (IOException e1) {
				}
			}
		}

		JSONObject all = new JSONObject(str.toString());
		Iterator<String> it = all.keys();
		while (it.hasNext()) {
			String code = it.next();
			printSet(all, code);
		}
	}

}
